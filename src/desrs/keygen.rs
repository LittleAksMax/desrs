static PC_1: [u8; 56] = [
    57, 49, 41, 33, 25, 17,  9,
     1, 58, 50, 42, 34, 26, 18,
    10,  2, 59, 51, 43, 35, 27,
    19, 11,  3, 60, 52, 44, 36,
    63, 55, 47, 39, 31, 23, 15, 
     7, 62, 54, 46, 38, 30, 22,
    14,  6, 61, 53, 45, 37, 29,
    21, 13,  5, 28, 20, 12,  4,
];

static SHIFT_SCHEDULE: [u8; 16] = [
    1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
];

static PC_2: [u8; 48] = [
    14, 17, 11, 24,  1,  5,
    3,  28, 15,  6, 21, 10,
    23, 19, 12,  4, 26,  8,
    16,  7, 27, 20, 13,  2,
    41, 52, 31, 37, 47, 55,
    30, 40, 51, 45, 33, 48,
    44, 49, 39, 56, 34, 53,
    46, 42, 50, 36, 29, 32,
];

fn pc_1(key64: u64) -> u64 {
    let mut key56: u64 = 0;
    for i in 0..56 {
        key56 <<= 1;
        key56 |= (key64 >> (64 - PC_1[i])) & 1;
    }
    key56
}

macro_rules! lrot {
    ($s:expr, $n:expr) => ((($s >> (28 - $n)) | ($s << $n)) & 0xFFFFFFF)
}

fn pc_2(key56: u64) -> u64 {
    let mut key48: u64 = 0;
    for i in 0..48 {
        key48 <<= 1;
        key48 |= (key56 >> (56 - PC_2[i])) & 1;
    }
    key48
}

pub fn create_subkeys(key64: u64) -> [u64; 16] {
    // perform PC_1
    let key56: u64 = pc_1(key64);

    let mut c = (key56 >> 24) & 33554431; // 24 rightmost bits
    let mut d = key56 & 33554431;

    let mut keys: [u64; 16] = [0; 16];

    // 16 rounds
    for i in 0_usize..16_usize {
        // shift each half according to schedule
        c = lrot!(c, SHIFT_SCHEDULE[i]);
        d = lrot!(d, SHIFT_SCHEDULE[i]);

        keys[i] = pc_2((c << 28) | d);
    }

    return keys;
}

#[cfg(test)]
mod tests {
    use super::{pc_1, pc_2, SHIFT_SCHEDULE};

    static K: u64 = 0b0001001100110100010101110111100110011011101111001101111111110001;

    static K_PLUS: u64 =  0b11110000110011001010101011110101010101100110011110001111;

    static C0: u64 = 0b1111000011001100101010101111;

    static D0: u64 = 0b0101010101100110011110001111;

    static SUBKEYS: [(u64, u64); 16] = [
        (0b1110000110011001010101011111, 0b1010101011001100111100011110),
        (0b1100001100110010101010111111, 0b0101010110011001111000111101),
        (0b0000110011001010101011111111, 0b0101011001100111100011110101),
        (0b0011001100101010101111111100, 0b0101100110011110001111010101),
        (0b1100110010101010111111110000, 0b0110011001111000111101010101),
        (0b0011001010101011111111000011, 0b1001100111100011110101010101),
        (0b1100101010101111111100001100, 0b0110011110001111010101010110),
        (0b0010101010111111110000110011, 0b1001111000111101010101011001),
        (0b0101010101111111100001100110, 0b0011110001111010101010110011),
        (0b0101010111111110000110011001, 0b1111000111101010101011001100),
        (0b0101011111111000011001100101, 0b1100011110101010101100110011),
        (0b0101111111100001100110010101, 0b0001111010101010110011001111),
        (0b0111111110000110011001010101, 0b0111101010101011001100111100),
        (0b1111111000011001100101010101, 0b1110101010101100110011110001),
        (0b1111100001100110010101010111, 0b1010101010110011001111000111),
        (0b1111000011001100101010101111, 0b0101010101100110011110001111),
    ];

    static ROUND_KEYS: [u64; 16] = [
        0b000110110000001011101111111111000111000001110010,
        0b011110011010111011011001110110111100100111100101,
        0b010101011111110010001010010000101100111110011001,
        0b011100101010110111010110110110110011010100011101,
        0b011111001110110000000111111010110101001110101000,
        0b011000111010010100111110010100000111101100101111,
        0b111011001000010010110111111101100001100010111100,
        0b111101111000101000111010110000010011101111111011,
        0b111000001101101111101011111011011110011110000001,
        0b101100011111001101000111101110100100011001001111,
        0b001000010101111111010011110111101101001110000110,
        0b011101010111000111110101100101000110011111101001,
        0b100101111100010111010001111110101011101001000001,
        0b010111110100001110110111111100101110011100111010,
        0b101111111001000110001101001111010011111100001010,
        0b110010110011110110001011000011100001011111110101,
    ];

    #[test]
    fn pc_1_permutes_correctly() {
        let result: u64   = pc_1(K);
        assert_eq!(K_PLUS, result);
    }

    #[test]
    fn subkey_rotations_work_correctly() {
        let mut c: u64 = C0;
        let mut d: u64 = D0;

        // check for each of the 16 rounds
        for i in 0_usize..16_usize {
            // shift each half according to schedule
            c = lrot!(c, SHIFT_SCHEDULE[i]);
            d = lrot!(d, SHIFT_SCHEDULE[i]);

            assert!(c >> 28 == 0 && d >> 28 == 0);

            assert_eq!(c, SUBKEYS[i].0);
            assert_eq!(d, SUBKEYS[i].1);
        }
    }

    #[test]
    fn pc_2_permutes_correctly() {
        // check for each of the 16 rounds
        for i in 0_usize..16_usize {
            assert_eq!(pc_2((SUBKEYS[i].0 << 28) | SUBKEYS[i].1), ROUND_KEYS[i]);
        }
    }
}